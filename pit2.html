<!DOCTYPE html>
<html>
<head>
	<title>Pit Building</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
</head>
<body>

<div id="pit"></div>

<p id="blockreport"></p>

<p id="action"></p>

<button onclick="newBlock.moveLeft()">Move Left</button>
<button onclick="newBlock.moveRight()">Move Right</button>
<br>
<button onclick="newBlock.dropToBottom()">Drop</button>
<button id="pause" onclick="pause()">Pause</button>

<h3>Scoreboard</h3>
<p>Lines: <span id="lines"></span></p>
<p>Score: <span id="score"></span></p>

<script>
	
	

	var lines = 0;
	var score = 0;
	var tetris = 0;
	var paused = false;
	var rowNumbers = true;
	var blank = "  ";
/*	var filled = "&#9608;&#9608;"*/
	var filled = "&#9633 "

	//
	// Initial device orientation detection
	//

	var initialOrientation = "";

	// Get the width and height of the browser window
	// and set initialOrientation to portrait or landscape accordingly

	width = window.innerWidth;
	height = window.innerHeight;
	initialOrientation = (width > height ? "landscape" : "portrait");


	//
	// Swipe and tap detection
	//

	var startX;
	var startY;

	function touchStart(e)
	{
		e.preventDefault();

		var touch = e.changedTouches[0];
		
		startX = touch.clientX;
		startY = touch.clientY;

	}

	function touchEnd(e)
	{
		e.preventDefault();

		var touch = e.changedTouches[0];
		
		endX = touch.clientX;
		endY = touch.clientY;

		changeX = startX-endX;
		changeY = startY-endY;

		if (Math.abs(changeX) < 7 && Math.abs(changeY) < 7) {	
			action = "clockwise";								// Tap
		}
		else {
			if (Math.abs(changeX) > Math.abs(changeY)) {
				if (changeX > 0) {
					action = "left";
					newBlock.moveLeft();						// Left swipe
				}
				else {
					action = "right";
					newBlock.moveRight();						// Right swipe
				}
			}
			else {
				if (changeY > 0) {
					action = "counter-clockwise";				// Up swipe
				}	
				else {
					action = "fall";							// Down swipe
					newBlock.dropToBottom();
				}
			}
		}

		document.getElementById('action').innerHTML = action;
	}

	function updateScores() {
		document.getElementById('lines').innerHTML = lines;
		document.getElementById('score').innerHTML = score;
	}

	function pitTemplate(orientation,blank) {

		this.orientation = orientation;
		this.blank = blank;
		
		// Set width and height of pit based on screen orientation
		this.w = (this.orientation == "landscape" ? 15 : 10);
		this.h = (this.orientation == "landscape" ? 10 : 15);

		// Find center of pit -- where new blocks appear
		this.center = (parseInt(this.w))/2-1; 

		// Add new blank row (array) at top of pit based on width
		this.addRow = function() {
			var newRow = new Array();
			for (var i = 0; i < this.w; i++) {
				newRow[i] = this.blank;
			}
			this.matrix.unshift(newRow);
		}

		// Create pit matrix of blank rows based on height 
		this.matrix = new Array();
		for (var i = 0; i < this.h; i++) {
			this.addRow();
		}

		// Update matrix space
		this.updateSpace = function(row,column,character) {
			this.matrix[row][column] = character;
		}

		// Output pit, from matrix array, in pit div
		this.printPit = function() {
			var matrixHTML = "<pre>"
			
			// Column numbers (for testing)
			if (rowNumbers) {
				matrixHTML += "    ";
				for (var i = 0; i < this.w; i++) {
					matrixHTML += i + " ";
				}
				matrixHTML += "\n";
			}

			// Top boundary
			matrixHTML += "   -";
			for (var i = 0; i < this.w; i++) {
				matrixHTML += "--"
			}
			matrixHTML += "\n";

			// Rows
			for (var i = 0; i < this.h; i++) {

				//Row numbers for testing
				if (rowNumbers) {
					if (i < 10) {
						matrixHTML += " ";
					}
					matrixHTML += i;
				}
				else {
					matrixHTML += "  ";
				}
				matrixHTML += "| ";
				for (var j = 0; j < this.w; j++) {
					matrixHTML += String(this.matrix[i][j]);
				}
				matrixHTML += "|\n";
			}

			// Bottom boundary
			matrixHTML += "   -";
			for (var i = 0; i < this.w; i++) {
				matrixHTML += "--"
			}

			// Column numbers (for testing)
			if (rowNumbers) {
				matrixHTML += "\n    ";
				for (var i = 0; i < this.w; i++) {
					matrixHTML += i + " ";
				}
				matrixHTML += "\n";
			}

			matrixHTML += "</pre>";

			document.getElementById('pit').innerHTML = matrixHTML;
		}

		this.getLastFreeRowForColumn = function(currentRow,column) {
			var lastFreeRow = this.h-1;
			for (var row = currentRow+1; row < this.h; row++) {
				if (this.matrix[row][column] != pit.blank) {
					lastFreeRow = row-1;
					return lastFreeRow;
				}
			}
			return lastFreeRow;
		}

		this.getLastFreeColumnToRightForRow = function(currentColumn, row) {
			var lastFreeColumn = this.w-1;
			for (var column = currentColumn + 1; column < this.w; column++) {
				if (this.matrix[row][column] != pit.blank) {
					lastFreeColumn = column-1;
					return lastFreeColumn;
				}
			}
			return lastFreeColumn;
		}

		this.getLastFreeColumnToLeftForRow = function(currentColumn, row) {
			var lastFreeColumn = 0;
			for (var column = currentColumn - 1; column >= 0; column--) {
				if (this.matrix[row][column] != pit.blank) {
					lastFreeColumn = column+1;
					return lastFreeColumn;
				}
			}
			return lastFreeColumn;
		}

		this.checkRows = function(topRow) {
			this.turnlines = 0;
			for (i = this.h-1; i >= topRow; i--) {
				var full = true;
				for (j = 0; j < this.w; j++) {
					if (this.matrix[i][j] == pit.blank) {
						full = false;
					}
				}
				if (full) {
					this.matrix.splice(i,1);
					this.addRow();
					this.turnlines++;
				}
			}
			scoreTurn(this.turnlines);
		}

	}

	function block(type) {
		this.type = type;
		this.top = 0;
		this.left = pit.center;
		pit.updateSpace(this.top,this.left,filled);
		pit.printPit();

		this.moveRight = function() {
			if (!paused) {
				var lastFreeColumn = pit.getLastFreeColumnToRightForRow(this.left,this.top);
				if (this.left < lastFreeColumn) {
					this.left += 1;
					pit.updateSpace(this.top,this.left-1,pit.blank);	
					pit.updateSpace(this.top,this.left,filled);	
					pit.printPit();
				}
			}
		}

		this.moveLeft = function() {
			if (!paused) {
				var lastFreeColumn = pit.getLastFreeColumnToLeftForRow(this.left,this.top);
				if (this.left > lastFreeColumn) {
					this.left -= 1;
					pit.updateSpace(this.top,this.left+1,pit.blank);	
					pit.updateSpace(this.top,this.left,filled);
					pit.printPit();
				}
			}
		}

		this.dropToBottom = function() {
			if (!paused) {
				var lastFreeRow = pit.getLastFreeRowForColumn(this.top,this.left);
				if (this.top < lastFreeRow) {
					pit.updateSpace(this.top,this.left,pit.blank);				
					this.top = lastFreeRow;
					pit.updateSpace(this.top,this.left,filled);				
					pit.printPit();
				}
			}	
		}

	}

	// Drop block one space, reset timer to drop again unless at last free row
	function drop() {
		if (!paused) {
			var lastFreeRow = pit.getLastFreeRowForColumn(newBlock.top,newBlock.left);
			if (newBlock.top < lastFreeRow) {
				newBlock.top += 1;
				document.getElementById('blockreport').innerHTML = 'Block is at row ' + newBlock.top;
				pit.updateSpace(newBlock.top-1,newBlock.left,pit.blank);
				pit.updateSpace(newBlock.top,newBlock.left,filled);				
				pit.printPit();
				window.setTimeout(drop,500);
			}
			else {
				document.getElementById('blockreport').innerHTML = 'Block is at row ' + newBlock.top + ' and is done dropping';
				pit.checkRows(newBlock.top);
			}
		}
	}

	// Pause and resume game
	function pause() {
		if (!paused) {
			paused = true;
			document.getElementById('pause').innerHTML = "Resume";
		}
		else {
			paused = false;
			document.getElementById('pause').innerHTML = "Pause";
			window.setTimeout(this.drop,1000);
		}
	}

	// Score turn and update scoreboard based on lines completed
	// then start new turn with a new block
	function scoreTurn(turnlines) {
		lines += turnlines;
		switch (turnlines) {
			case 0:
				tetris = 0;
				break;
			case 1:
				tetris = 0;
				score += 100;
				break;
			case 2:
				tetris = 0;
				score += 300;
				break;
			case 3:
				tetris = 0;
				score += 600;
				break;
			case 4:
				tetris ++;
				score += 800;
				break;
		}
		if (tetris == 2) {
			score += 1600;
			tetris = 0;
		}
		updateScores();
		newBlock = new block(1); 
		window.setTimeout(drop,500);
	}

	//
	// Touch event and screen orientation listeners
	//

	window.addEventListener('touchstart', touchStart, false);
	window.addEventListener('touchend', touchEnd, false);

	//
	// Initialize new game
	//

	// Create pit object
	var pit = new pitTemplate(initialOrientation,blank);

	// Print blank bit
	pit.printPit();

	// Set scoreboard
	updateScores();
	
	// Start game with new block
	var newBlock = new block(1); 
	window.setTimeout(drop,500);




</script>

</body>
</html>  

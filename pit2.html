<!DOCTYPE html>
<html>
<head>
	<title>Pit Building</title>
</head>
<body>

<div id="pit"></div>

<p id="blockreport"></p>

<button onclick="moveLeft()">Move Left</button>
<button onclick="moveRight()">Move Right</button>
<button onclick="dropToBottom()">Drop</button>
<button id="pause" onclick="pause()">Pause</button>

<h3>Scoreboard</h3>
<p>Lines: <span id="lines"></span></p>
<p>Score: <span id="score"></span></p>

<script>

	var lines = 0;
	var score = 0;
	var tetris = 0;
	var paused = false;

	function updateScores() {
		document.getElementById('lines').innerHTML = lines;
		document.getElementById('score').innerHTML = score;
	}

	function pitTemplate(orientation) {
		
		// Set width and height of pit based on screen orientation
		this.w = (this.orientation == "landscape" ? 15 : 10);
		this.h = (this.orientation == "landscape" ? 10 : 15);
		
		
		/*// Create blank row array based on width
		this.blankRow = new Array();
		for (var i = 0; i < this.w; i++) {
			this.blankRow[i] = "0";
		}*/

		this.blankRow = "";
		for (var i = 0; i < this.w; i++) {
			this.blankRow += "0";
		}

		// Create pit array based on height and width
		this.matrix = new Array();
		for (var i = 0; i < this.h; i++) {
			this.matrix[i] = new Array();
			for (var j = 0; j < this.w; j++) {
				this.matrix[i][j] = "0";
			}
		}

		// Update matrix space
		this.updateSpace = function(row,column,character) {
			this.matrix[row][column] = character;
		}


		// Output pit, from matrix array, in pit div
		this.printPit = function() {
			var matrixHTML = "<pre>"
			for (var i = 0; i < this.h; i++) {
				for (var j = 0; j < this.w; j++) {
					matrixHTML += String(this.matrix[i][j]) + " ";
				}
				matrixHTML += "\n";
			}
			matrixHTML += "</pre>";
			document.getElementById('pit').innerHTML = matrixHTML;
		}

		this.getLastFreeRowForColumn = function(currentRow,column) {
			var lastFreeRow = this.h-1;
			for (var row = currentRow+1; row < this.h; row++) {
				if (this.matrix[row][column] != "0") {
					lastFreeRow = row-1;
					return lastFreeRow;
				}
			}
			return lastFreeRow;
		}

		this.getLastFreeColumnToRightForRow = function(currentColumn, row) {
			var lastFreeColumn = this.w-1;
			for (var column = currentColumn + 1; column < this.w; column++) {
				if (this.matrix[row][column] != "0") {
					lastFreeColumn = column-1;
					return lastFreeColumn;
				}
			}
			return lastFreeColumn;
		}

		this.getLastFreeColumnToLeftForRow = function(currentColumn, row) {
			var lastFreeColumn = 0;
			for (var column = currentColumn - 1; column >= 0; column--) {
				if (this.matrix[row][column] != "0") {
					lastFreeColumn = column+1;
					return lastFreeColumn;
				}
			}
			return lastFreeColumn;
		}

		this.checkRows = function(topRow) {
			this.turnlines = 0;
			for (i = this.h-1; i >= topRow; i--) {
				var full = true;
				for (j = 0; j < this.w; j++) {
					if (this.matrix[i][j] == "0") {
						full = false;
					}
				}
				if (full) {
					this.matrix.splice(i,1);
					this.matrix.unshift(this.blankRow);
					this.turnlines++;
				}
			}
			
			// Scoring - MOVE INTO SEPARATE FUNCTION?
			lines += this.turnlines;
			switch (this.turnlines) {
				case 0:
					tetris = 0;
					break;
				case 1:
					tetris = 0;
					score += 100;
					break;
				case 2:
					tetris = 0;
					score += 300;
					break;
				case 3:
					tetris = 0;
					score += 600;
					break;
				case 4:
					tetris ++;
					score += 800;
					break;
			}
			if (tetris == 2) {
				score += 1600;
				tetris = 0;
			}
			updateScores();
			newBlock();

		}

	}

	function newBlock () {
		blockType = "cube";
		blockTop = 0;
		blockLeft = (parseInt(pit.w))/2-1; 
		pit.updateSpace(blockTop,blockLeft,"X");
		pit.printPit();
		window.setTimeout(drop,500);
	}

	function drop() {
		if (!paused) {
			var lastFreeRow = pit.getLastFreeRowForColumn(blockTop,blockLeft);
			if (blockTop < lastFreeRow) {
				blockTop += 1;
				document.getElementById('blockreport').innerHTML = 'Block is at row ' + blockTop;
				pit.updateSpace(blockTop-1,blockLeft,"0");
				pit.updateSpace(blockTop,blockLeft,"X");				
				pit.printPit();
				window.setTimeout(drop,500);
			}
			else {
				document.getElementById('blockreport').innerHTML = 'Block is at row ' + blockTop + ' and is done dropping';
				pit.checkRows(blockTop);
			}
		}
	}

	function moveRight() {
		if (!paused) {
			var lastFreeColumn = pit.getLastFreeColumnToRightForRow(blockLeft,blockTop);
			if (blockLeft < lastFreeColumn) {
				blockLeft += 1;
				pit.updateSpace(blockTop,blockLeft-1,"0");	
				pit.updateSpace(blockTop,blockLeft,"X");	
				pit.printPit();
			}
		}
	}

	function moveLeft() {
		if (!paused) {
			var lastFreeColumn = pit.getLastFreeColumnToLeftForRow(blockLeft,blockTop);
			if (blockLeft > lastFreeColumn) {
				blockLeft -= 1;
				pit.updateSpace(blockTop,blockLeft+1,"0");	
				pit.updateSpace(blockTop,blockLeft,"X");
				pit.printPit();
			}
		}
	}

	function dropToBottom() {
		if (!paused) {
			var lastFreeRow = pit.getLastFreeRowForColumn(blockTop,blockLeft);
			if (blockTop < lastFreeRow) {
				pit.updateSpace(blockTop,blockLeft,"0");				
				blockTop = lastFreeRow;
				pit.updateSpace(blockTop,blockLeft,"X");				
				pit.printPit();
			}
		}	
	}

	function pause() {
		if (!paused) {
			paused = true;
			document.getElementById('pause').innerHTML = "Resume";
		}
		else {
			paused = false;
			document.getElementById('pause').innerHTML = "Pause";
			window.setTimeout(drop,1000);
		}
	}

	var pit = new pitTemplate("landscape");

	pit.printPit();

	updateScores();
	
	newBlock(); 


</script>

</body>
</html>  

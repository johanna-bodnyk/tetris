<!DOCTYPE html>
<html>
<head>
	<title>Pit Building</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
</head>
<body>

<div id="pit"></div>

<p id="blockreport"></p>
<p id="fitreport"></p>
<p id="action"></p>

<button onclick="block.moveLeft()">Move Left</button>
<button onclick="block.moveRight()">Move Right</button>
<button onclick="block.rotate(1)">Rotate</button>
<br>
<button onclick="block.dropToBottom()">Drop</button>
<button id="pause" onclick="pause()">Pause</button>

<h3>Scoreboard</h3>
<p>Lines: <span id="lines">0</span></p>
<p>Score: <span id="score">0</span></p>
<p>Game time: <span id="time">00:00</span></p>

<script>
	
	

	var lines = 0;
	var score = 0;
	var userLocation = "test";
	var gameTime = 0;
	var tetris = 0;
	var paused = false;
	var gameOver = false;
	var rowNumbers = true;
	var blank = " ";

	//
	// Sound effects
	//
	var clearRowSound = new Audio("sounds/clear-row.wav");
	var touchSound = new Audio("sounds/touch.wav")

	//
	// Initial device orientation detection
	//

	var initialOrientation = "";

	// Get the width and height of the browser window
	// and set initialOrientation to portrait or landscape accordingly

	width = window.innerWidth;
	height = window.innerHeight;
	initialOrientation = (width > height ? "landscape" : "portrait");


	//
	// Swipe and tap detection
	//

	var startX;
	var startY;

	function touchStart(e)
	{
		e.preventDefault();

		var touch = e.changedTouches[0];
		
		startX = touch.clientX;
		startY = touch.clientY;

	}

	function touchEnd(e)
	{
		e.preventDefault();

		var touch = e.changedTouches[0];
		
		endX = touch.clientX;
		endY = touch.clientY;

		changeX = startX-endX;
		changeY = startY-endY;

		if (Math.abs(changeX) < 7 && Math.abs(changeY) < 7) {
			touchSound.play();
			touchSound.currentTime=0;
			action = "clockwise";								// Tap
			block.rotate(1);
		}
		else {
			if (Math.abs(changeX) > Math.abs(changeY)) {
				if (changeX > 0) {
					touchSound.play();
					touchSound.currentTime=0;
					action = "left";
					block.moveLeft();						// Left swipe
				}
				else {
					touchSound.play();
					touchSound.currentTime=0;
					action = "right";
					block.moveRight();						// Right swipe
				}
			}
			else {
				if (changeY > 0) {
					touchSound.play();
					touchSound.currentTime=0;
					action = "counter-clockwise";				// Up swipe
					block.rotate(0);
				}	
				else {
					touchSound.play();
					touchSound.currentTime=0;
					action = "fall";							// Down swipe
					block.dropToBottom();
				}
			}
		}

		document.getElementById('action').innerHTML = action;
	}

	function updateScores() {
		document.getElementById('lines').innerHTML = lines;
		document.getElementById('score').innerHTML = score;
	}

	function Pit(orientation,blank) {

		this.orientation = orientation;
		this.blank = blank;
		
		// Set width and height of pit based on screen orientation
		this.w = (this.orientation == "landscape" ? 15 : 10);
		this.h = (this.orientation == "landscape" ? 10 : 15);

		// Find center of pit -- where new blocks appear
		this.center = (parseInt(this.w/2))-1;

		// Add new blank row (array) at top of pit based on width
		this.addRow = function() {
			var newRow = new Array();
			for (var i = 0; i < this.w; i++) {
				newRow[i] = this.blank;
			}
			this.matrix.unshift(newRow);
		}

		// Create pit matrix of blank rows based on height 
		this.matrix = new Array();
		for (var i = 0; i < this.h; i++) {
			this.addRow();
		}

		// Update matrix space
		this.updateSpace = function(column,row,character) {
			this.matrix[row][column] = character;
		}

		// Output pit, from matrix array, in pit div
		this.printPit = function() {
			var matrixHTML = "<pre>"
			
			// Column numbers (for testing)
			if (rowNumbers) {
				matrixHTML += "   ";
				for (var i = 0; i < this.w; i++) {
					matrixHTML += i;
				}
				matrixHTML += "\n";
			}

			// Top boundary
			matrixHTML += "   ";
			for (var i = 0; i < this.w; i++) {
				matrixHTML += "-"
			}
			matrixHTML += "\n";

			// Rows
			for (var i = 0; i < this.h; i++) {

				//Row numbers for testing
				if (rowNumbers) {
					if (i < 10) {
						matrixHTML += " ";
					}
					matrixHTML += i;
				}
				else {
					matrixHTML += "  ";
				}
				matrixHTML += "|";
				for (var j = 0; j < this.w; j++) {
					matrixHTML += String(this.matrix[i][j]);
				}
				matrixHTML += "|\n";
			}

			// Bottom boundary
			matrixHTML += "   ";
			for (var i = 0; i < this.w; i++) {
				matrixHTML += "-"
			}

			// Column numbers (for testing)
			if (rowNumbers) {
				matrixHTML += "\n   ";
				for (var i = 0; i < this.w; i++) {
					matrixHTML += i;
				}
				matrixHTML += "\n";
			}

			matrixHTML += "</pre>";

			document.getElementById('pit').innerHTML = matrixHTML;
		}

		this.getLastFreeRowForColumn = function(column, currentRow) {
			var lastFreeRow = this.h-1;
			for (var row = currentRow+1; row < this.h; row++) {
				if (this.matrix[row][column] != pit.blank && this.matrix[row][column] != block.type) {
					lastFreeRow = row-1;
					return lastFreeRow;
				}
			}
			return lastFreeRow;
		}

		this.getLastFreeColumnToRightForRow = function(currentColumn, row) {
			var lastFreeColumn = this.w-1;
			for (var column = currentColumn + 1; column < this.w; column++) {
				if (this.matrix[row][column] != pit.blank && this.matrix[row][column] != block.type) {
					lastFreeColumn = column-1;
					return lastFreeColumn;
				}
			}
			return lastFreeColumn;
		}

		this.getLastFreeColumnToLeftForRow = function(currentColumn, row) {
			var lastFreeColumn = 0;
			for (var column = currentColumn - 1; column >= 0; column--) {
				if (this.matrix[row][column] != pit.blank && this.matrix[row][column] != block.type) {
					lastFreeColumn = column+1;
					return lastFreeColumn;
				}
			}
			return lastFreeColumn;
		}

		this.checkRows = function() {
			var turnLines = 0;
			for (var i = 0; i < this.h; i++) {
				var full = true;
				for (var j = 0; j < this.w; j++) {
					if (this.matrix[i][j] == this.blank) {
						full = false;
					}
				}
				if (full) {
					clearRowSound.play();
					this.matrix.splice(i,1);
					this.addRow();
					turnLines++;
				}
			}
			return turnLines;
		}
	}

	function Block() {

		// Randomly set block type
		var typeNumber = Math.floor(Math.random()*7);
		// var typeNumber = 0;
		var types = ["C","I","J","L","S","T","Z"];
		this.type = types[typeNumber];

		// Set rotation to 0 and start block off at top center of pit
		this.rotation = 0;
		this.top = 0;
		this.left = pit.center;

		this.blockSpots = {
			'C': {
				0: [
					[0,0],
					[1,0],
					[0,1],
					[1,1]
				],
				90: [
					[0,0],
					[1,0],
					[0,1],
					[1,1]
				],
				180: [
					[0,0],
					[1,0],
					[0,1],
					[1,1]
				],
				270: [
					[0,0],
					[1,0],
					[0,1],
					[1,1]
				]
			},
			'I': {
				0: [
					[0,0],
					[0,1],
					[0,2],
					[0,3]
				],
				90: [
					[0,0],
					[1,0],
					[2,0],
					[3,0]
				],
				180: [
					[0,0],
					[0,1],
					[0,2],
					[0,3]
				],
				270: [
					[0,0],
					[1,0],
					[2,0],
					[3,0]
				]
			},
			'L': {
				0: [
					[0,0],
					[0,1],
					[0,2],
					[1,2]
				],
				90: [
					[0,0],
					[1,0],
					[2,0],
					[0,1]
				],
				180: [
					[0,0],
					[1,0],
					[1,1],
					[1,2]
				],
				270: [
					[2,0],
					[0,1],
					[1,1],
					[2,1]
				]
			},
			'J': {
				0: [
					[1,0],
					[1,1],
					[0,2],
					[1,2]
				],
				90: [
					[0,0],
					[0,1],
					[1,1],
					[2,1]
				],		
				180: [
					[0,0],
					[1,0],
					[0,1],
					[0,2]
				],
				270: [
					[0,0],
					[1,0],
					[2,0],
					[2,1]
				]
			},
			'T': {
				0: [
					[0,0],
					[1,0],
					[2,0],
					[1,1]
				],
				90: [
					[1,0],
					[0,1],
					[1,1],
					[1,2]
				],		
				180: [
					[1,0],
					[0,1],
					[1,1],
					[2,1]
				],
				270: [
					[0,0],
					[0,1],
					[1,1],
					[0,2]
				]
			},
			'S': {
				0: [
					[1,0],
					[2,0],
					[0,1],
					[1,1]
				],
				90: [
					[0,0],
					[0,1],
					[1,1],
					[1,2]
				],		
				180: [
					[1,0],
					[2,0],
					[0,1],
					[1,1]
				],
				270: [
					[0,0],
					[0,1],
					[1,1],
					[1,2]
				]
			},
			'Z': {
				0: [
					[0,0],
					[1,0],
					[1,1],
					[2,1]
				],
				90: [
					[1,0],
					[0,1],
					[1,1],
					[0,2]
				],		
				180: [
					[0,0],
					[1,0],
					[1,1],
					[2,1]
				],
				270: [
					[1,0],
					[0,1],
					[1,1],
					[0,2]
				]
			}
		}

		this.testBlock = function() {
			var fits = true;
			var inPit = false;
			for (var i = 0; i < 4; i++)	{
				var X = this.blockSpots[this.type][this.rotation][i][0] + this.left;
				var Y = this.blockSpots[this.type][this.rotation][i][1] + this.top;
				if (Y >= 0) {
					inPit = true;
					if (pit.matrix[Y][X] != pit.blank) {fits = false;}
				}
			}
			if (fits && inPit) {
				return true;
			}
			else if (this.top > -3) {
				this.top--;
				this.testBlock();
			}
			else {
				return false;
			}
		}

		this.drawBlock = function(mode) {
			if (mode == "move") {
				character = this.type;
			}
			else if (mode == "final") {
				character = this.type.toLowerCase();
			}
			else {
				character = blank;
			}
			for (var i = 0; i < 4; i++)	{
				var X = this.blockSpots[this.type][this.rotation][i][0] + this.left;
				var Y = this.blockSpots[this.type][this.rotation][i][1] + this.top;
				if (Y >= 0) {pit.updateSpace(X,Y,character);}
			}
			pit.printPit();
		}

		// Drop block one space, reset timer to drop again unless at last free row
		this.drop = function() {
			if (!paused) {
				var bottomLimit = this.findBottomLimit();
				if (this.top < bottomLimit) {
					this.drawBlock("erase");
					this.top++;
					document.getElementById('blockreport').innerHTML = 'Block is at row ' + this.top;
					this.drawBlock("move");
					window.setTimeout("block.drop()",1000);
				}
				else {
					endTurn();
				}
			}
		}

		this.moveRight = function() {
			if (!paused) {
				var rightLimit = this.findRightLimit();
				if (this.left < rightLimit) {
					this.drawBlock("erase");
					this.left++;
					this.drawBlock("move");
				}
			}
		}

		this.moveLeft = function() {
			if (!paused) {
				var leftLimit = this.findLeftLimit();
				if (this.left > leftLimit) {
					this.drawBlock("erase");
					this.left--;
					this.drawBlock("move");
				}
			}
		}

		this.dropToBottom = function() {
			if (!paused) {
				var bottomLimit = this.findBottomLimit();
				if (this.top < bottomLimit) {
					this.drawBlock("erase");				
					this.top = bottomLimit;
					this.drawBlock("final")				
				}
			}	
		}

		// Find lowest point block can drop to
		this.findBottomLimit = function() {
			var bottomLimit = pit.h-1;
			var spots = this.blockSpots[this.type][this.rotation];
			for (var i = 0; i < 4; i++) {
				var columnToCheck = spots[i][0] + this.left;
				var rowToStartFrom = spots[i][1] + this.top;
				var bottomForColumn = pit.getLastFreeRowForColumn(columnToCheck,rowToStartFrom)
				bottomForColumn -= spots[i][1];
				if (bottomForColumn < bottomLimit) {
					bottomLimit = bottomForColumn;
				}
			}
			return bottomLimit;
		}

		// Find right-most point block can move to
		this.findRightLimit = function() {
			var rightLimit = pit.w-1;
			var spots = this.blockSpots[this.type][this.rotation];
			for (var i = 0; i < 4; i++) {
				var columnToStartFrom = spots[i][0] + this.left;
				var rowToCheck = spots [i][1] + this.top;
				var rightLimitForRow = pit.getLastFreeColumnToRightForRow(columnToStartFrom,rowToCheck);
				rightLimitForRow -= spots[i][0];
				if (rightLimitForRow < rightLimit) {
					rightLimit = rightLimitForRow;
				}
			}
			return rightLimit;
		}

		// Find left-most point block can move to
		this.findLeftLimit = function() {
			var leftLimit = 0;
			var spots = this.blockSpots[this.type][this.rotation];
			for (var i = 0; i < 4; i++) {
				var columnToStartFrom = spots[i][0] + this.left;
				var rowToCheck = spots[i][1] + this.top;
				var leftLimitForRow = pit.getLastFreeColumnToLeftForRow(columnToStartFrom,rowToCheck);
				leftLimitForRow -= spots[i][0];
				if (leftLimitForRow > leftLimit) {
					leftLimit = leftLimitForRow;
				}
			}
			return leftLimit;
		}

		//
		// Rotation!
		//

		this.rotate = function(clockwise) {

			// Get new rotation, clockwise +90 or counterclockwise -90
			newRotation = this.rotation + (clockwise ? 90 : -90);
			if (newRotation > 270 || newRotation < 0) {
				newRotation = 0;
			}
			
			// Check to see if block will move outside pit with new rotation,
			// or overlap existing blocks
			var illegalRotation = false;
			var spotsChecked = "";
			for (var i = 0; i < 4; i++) {
				var newColumn = this.blockSpots[this.type][newRotation][i][0] + this.left;
				var newRow = this.blockSpots[this.type][newRotation][i][1] + this.top;
				if (newColumn >= pit.w || (pit.matrix[newColumn][newRow] != pit.blank && pit.matrix[newColumn][newRow] != this.type)) {
					illegalRotation = true;
				}
				spotsChecked += newColumn + "," + newRow + ";";
			}

			// If block will stay in bounds, erase, set new rotation, and redraw
			if (!illegalRotation) {
				this.drawBlock("erase");
				this.rotation = newRotation;
				this.drawBlock("move");
			}
		}

	}


	function startTurn() {
		// Create new block and draw in pit
		block = new Block();
/*		block.drawBlock("move");
		window.setTimeout("block.drop()",1000);*/

		// Make sure block will fit at top of pit
		var fits = block.testBlock();

		if (fits == true) {
			if (block.top === 0) {			// If entire block fits, draw and start dropping
				document.getElementById("fitreport").innerHTML = "Fits!";
				block.drawBlock("move");
				window.setTimeout("block.drop()",1000);
			}
			else {							// FIGURE OUT WHY THIS ISN'T EXECUTING!!!
				document.getElementById("fitreport").innerHTML = "Fits partially";
				block.drawBlock("final");	// If only part will fit, draw as final and end game
				endGame();
			}
		}
		else {							
			document.getElementById("fitreport").innerHTML = "Does not fit";
			endGame();						// If no part will fit, end game without drawing block
		}
	}

	function endTurn() {
		// Set block characters to lowercase
		block.drawBlock("final");
		document.getElementById('blockreport').innerHTML = 'Block is at row ' + block.top + ' and is done dropping';

		// Check for completed rows
		var rowsCompleted = pit.checkRows();

		// Score turn based on completed rows and update display of scores
		scoreTurn(rowsCompleted);
		updateScores();

		// Start new turn
		startTurn();
	}

	// Score turn and update scoreboard based on lines completed
	// then start new turn with a new block
	function scoreTurn(rowsCompleted) {
		lines += rowsCompleted;
		switch (rowsCompleted) {
			case 0:
				tetris = 0;
				break;
			case 1:
				tetris = 0;
				score += 100;
				break;
			case 2:
				tetris = 0;
				score += 300;
				break;
			case 3:
				tetris = 0;
				score += 600;
				break;
			case 4:
				tetris ++;
				score += 800;
				break;
		}
		if (tetris == 2) {
			score += 1600;
			tetris = 0;
		}
	}

	function endGame() {
		gameOver = true;
		document.getElementById('blockreport').innerHTML = 'Block is at row ' + block.top + " and GAME OVER!";
		saveScore();
		sendScoreToServer();
	}

	//
	// Save score at end of game
	//

	function positionHandler(Position) {
		var latitude = Position.coords.latitude;
		var longitude = Position.coords.longitude;
		userLocation = latitude+","+longitude;
	}

	function positionErrorHandler() {
		userLocation = "denied";
	}

	function getLocation() {
		navigator.geolocation.getCurrentPosition(positionHandler, positionErrorHandler);
	}

	function sendScoreToServer() {
		getLocation();
		var webSocketData = "Name="+gameRecord.name+"&HighScore="+score+"&Location="+userLocation;
		// var websocket = new WebSocket('ws://technologeeks.com/e65/submit.php?user=johanna.bodnyk')
		var websocket = new WebSocket('ws://echo.websocket.org');
		websocket.onopen = function() {
			websocket.send(webSocketData);
		}
		websocket.onmessage = function (evt) { // For testing with echo.websocket.org
			console.log("Message received: " + evt.data);
		}
	}

	function saveScore() {
		// Save score locally
		gameRecord = {};
		gameRecord.lines = lines;
		gameRecord.score = score;
		gameRecord.gameTime = gameTime;
		gameRecord.name = prompt("Enter your name to save your score! (Or hit Cancel to save your score anonymously.)");
		if (gameRecord.name==null) {gameRecord.name = "Anonymous";}
		var recordId = Date.now();
		localStorage.setItem(recordId, JSON.stringify(gameRecord));

		// Get location to send to server, open send via websocket after location is check
		getLocation();
	}


	//
	// Pause and resume game
	//
	function pause() {
		if (!paused) {
			paused = true;
			document.getElementById('pause').innerHTML = "Resume";
		}
		else {
			paused = false;
			document.getElementById('pause').innerHTML = "Pause";
			window.setTimeout("block.drop()",1000); // Start dropping block again
			window.setTimeout(timer,1000); // Start timer again
		}
	}

	//
	//	Game timer
	//
	function timer() {
		if (!paused && !gameOver) {
			gameTime++;
			window.setTimeout(timer,1000);
		}
		var gameSeconds = gameTime%60;
		var gameMinutes = (gameTime-gameSeconds)/60;
		if (gameSeconds < 10) {gameSeconds = "0" + gameSeconds}; // Add 0 for single digits
		if (gameMinutes < 10) {gameMinutes = "0" + gameMinutes}; // Add 0 for single digits
		document.getElementById("time").innerHTML = gameMinutes + ":" + gameSeconds;
	}

	//
	// Touch event and screen orientation listeners
	//

	window.addEventListener('touchstart', touchStart, false);
	window.addEventListener('touchend', touchEnd, false);

	//
	// Initialize new game
	//

	// Create pit object
	var pit = new Pit(initialOrientation,blank);

	// Print blank bit
	pit.printPit();
	
	// Start game with new turn, and start timer
	startTurn();
	window.setTimeout(timer,1000);


</script>

</body>
</html>  

<!DOCTYPE html>
<html>
<head>
	<title>Pit Building</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
</head>
<body>

<div id="pit"></div>

<p id="blockreport"></p>

<p id="action"></p>

<button onclick="newBlock.moveLeft()">Move Left</button>
<button onclick="newBlock.moveRight()">Move Right</button>
<button onclick="newBlock.rotate(1)">Rotate</button>
<br>
<button onclick="newBlock.dropToBottom()">Drop</button>
<button id="pause" onclick="pause()">Pause</button>

<h3>Scoreboard</h3>
<p>Lines: <span id="lines"></span></p>
<p>Score: <span id="score"></span></p>
<p>Game time: <span id="time"></span></p>

<script>
	
	

	var lines = 0;
	var score = 0;
	var gametime = 0;
	var tetris = 0;
	var paused = false;
	var rowNumbers = true;
	var blank = " ";
/*	var filled = "&#9608;&#9608;"*/
/*	var filled = "&#9633"*/
	var filled = "X";


	//
	// Initial device orientation detection
	//

	var initialOrientation = "";

	// Get the width and height of the browser window
	// and set initialOrientation to portrait or landscape accordingly

	width = window.innerWidth;
	height = window.innerHeight;
	initialOrientation = (width > height ? "landscape" : "portrait");


	//
	// Swipe and tap detection
	//

	var startX;
	var startY;

	function touchStart(e)
	{
		e.preventDefault();

		var touch = e.changedTouches[0];
		
		startX = touch.clientX;
		startY = touch.clientY;

	}

	function touchEnd(e)
	{
		e.preventDefault();

		var touch = e.changedTouches[0];
		
		endX = touch.clientX;
		endY = touch.clientY;

		changeX = startX-endX;
		changeY = startY-endY;

		if (Math.abs(changeX) < 7 && Math.abs(changeY) < 7) {	
			action = "clockwise";								// Tap
		}
		else {
			if (Math.abs(changeX) > Math.abs(changeY)) {
				if (changeX > 0) {
					action = "left";
					newBlock.moveLeft();						// Left swipe
				}
				else {
					action = "right";
					newBlock.moveRight();						// Right swipe
				}
			}
			else {
				if (changeY > 0) {
					action = "counter-clockwise";				// Up swipe
				}	
				else {
					action = "fall";							// Down swipe
					newBlock.dropToBottom();
				}
			}
		}

		document.getElementById('action').innerHTML = action;
	}

	function updateScores() {
		document.getElementById('lines').innerHTML = lines;
		document.getElementById('score').innerHTML = score;
	}

	function pitTemplate(orientation,blank) {

		this.orientation = orientation;
		this.blank = blank;
		
		// Set width and height of pit based on screen orientation
		this.w = (this.orientation == "landscape" ? 15 : 10);
		this.h = (this.orientation == "landscape" ? 10 : 15);

		// Find center of pit -- where new blocks appear
		this.center = (parseInt(this.w/2))-1;

		// Add new blank row (array) at top of pit based on width
		this.addRow = function() {
			var newRow = new Array();
			for (var i = 0; i < this.w; i++) {
				newRow[i] = this.blank;
			}
			this.matrix.unshift(newRow);
		}

		// Create pit matrix of blank rows based on height 
		this.matrix = new Array();
		for (var i = 0; i < this.h; i++) {
			this.addRow();
		}

		// Update matrix space
		this.updateSpace = function(column,row,character) {
			this.matrix[row][column] = character;
		}

		// Output pit, from matrix array, in pit div
		this.printPit = function() {
			var matrixHTML = "<pre>"
			
			// Column numbers (for testing)
			if (rowNumbers) {
				matrixHTML += "   ";
				for (var i = 0; i < this.w; i++) {
					matrixHTML += i;
				}
				matrixHTML += "\n";
			}

			// Top boundary
			matrixHTML += "   ";
			for (var i = 0; i < this.w; i++) {
				matrixHTML += "-"
			}
			matrixHTML += "\n";

			// Rows
			for (var i = 0; i < this.h; i++) {

				//Row numbers for testing
				if (rowNumbers) {
					if (i < 10) {
						matrixHTML += " ";
					}
					matrixHTML += i;
				}
				else {
					matrixHTML += "  ";
				}
				matrixHTML += "|";
				for (var j = 0; j < this.w; j++) {
					matrixHTML += String(this.matrix[i][j]);
				}
				matrixHTML += "|\n";
			}

			// Bottom boundary
			matrixHTML += "   ";
			for (var i = 0; i < this.w; i++) {
				matrixHTML += "-"
			}

			// Column numbers (for testing)
			if (rowNumbers) {
				matrixHTML += "\n   ";
				for (var i = 0; i < this.w; i++) {
					matrixHTML += i;
				}
				matrixHTML += "\n";
			}

			matrixHTML += "</pre>";

			document.getElementById('pit').innerHTML = matrixHTML;
		}

		this.getLastFreeRowForColumn = function(column, currentRow) {
			var lastFreeRow = this.h-1;
			for (var row = currentRow+1; row < this.h; row++) {
				if (this.matrix[row][column] != pit.blank && this.matrix[row][column] != newBlock.type) {
					lastFreeRow = row-1;
					return lastFreeRow;
				}
			}
			return lastFreeRow;
		}

		this.getLastFreeColumnToRightForRow = function(currentColumn, row) {
			var lastFreeColumn = this.w-1;
			for (var column = currentColumn + 1; column < this.w; column++) {
				if (this.matrix[row][column] != pit.blank && this.matrix[row][column] != newBlock.type) {
					lastFreeColumn = column-1;
					return lastFreeColumn;
				}
			}
			return lastFreeColumn;
		}

		this.getLastFreeColumnToLeftForRow = function(currentColumn, row) {
			var lastFreeColumn = 0;
			for (var column = currentColumn - 1; column >= 0; column--) {
				if (this.matrix[row][column] != pit.blank && this.matrix[row][column] != newBlock.type) {
					lastFreeColumn = column+1;
					return lastFreeColumn;
				}
			}
			return lastFreeColumn;
		}

		this.checkRows = function() {
			this.turnlines = 0;
			for (var i = 0; i < this.h; i++) {
				var full = true;
				for (j = 0; j < this.w; j++) {
					if (this.matrix[i][j] == pit.blank) {
						full = false;
					}
				}
				if (full) {
					this.matrix.splice(i,1);
					this.addRow();
					this.turnlines++;
				}
			}
			scoreTurn(this.turnlines);
		}

	}

	function block() {

		// Randomly set block type
		var typeNumber = Math.floor(Math.random()*7);
		var types = ["C","I","J","L","S","T","Z"];
		this.type = types[typeNumber];

		// Set rotation to 0 and start block off at top center of pit
		this.rotation = 0;
		this.top = 0;
		this.left = pit.center;

		this.blockSpots = {
			'C': {
				0: [
					[0,0],
					[1,0],
					[0,1],
					[1,1]
				],
				90: [
					[0,0],
					[1,0],
					[0,1],
					[1,1]
				],
				180: [
					[0,0],
					[1,0],
					[0,1],
					[1,1]
				],
				270: [
					[0,0],
					[1,0],
					[0,1],
					[1,1]
				]
			},
			'I': {
				0: [
					[0,0],
					[0,1],
					[0,2],
					[0,3]
				],
				90: [
					[0,0],
					[1,0],
					[2,0],
					[3,0]
				],
				180: [
					[0,0],
					[0,1],
					[0,2],
					[0,3]
				],
				270: [
					[0,0],
					[1,0],
					[2,0],
					[3,0]
				]
			},
			'L': {
				0: [
					[0,0],
					[0,1],
					[0,2],
					[1,2]
				],
				90: [
					[0,0],
					[1,0],
					[2,0],
					[0,1]
				],
				180: [
					[0,0],
					[1,0],
					[1,1],
					[1,2]
				],
				270: [
					[2,0],
					[0,1],
					[1,1],
					[2,1]
				]
			},
			'J': {
				0: [
					[1,0],
					[1,1],
					[0,2],
					[1,2]
				],
				90: [
					[0,0],
					[0,1],
					[1,1],
					[2,1]
				],		
				180: [
					[0,0],
					[1,0],
					[0,1],
					[0,2]
				],
				270: [
					[0,0],
					[1,0],
					[2,0],
					[2,1]
				]
			},
			'T': {
				0: [
					[0,0],
					[1,0],
					[2,0],
					[1,1]
				],
				90: [
					[1,0],
					[0,1],
					[1,1],
					[1,2]
				],		
				180: [
					[1,0],
					[0,1],
					[1,1],
					[2,1]
				],
				270: [
					[0,0],
					[0,1],
					[1,1],
					[0,2]
				]
			},
			'S': {
				0: [
					[1,0],
					[2,0],
					[0,1],
					[1,1]
				],
				90: [
					[0,0],
					[0,1],
					[1,1],
					[1,2]
				],		
				180: [
					[1,0],
					[2,0],
					[0,1],
					[1,1]
				],
				270: [
					[0,0],
					[0,1],
					[1,1],
					[1,2]
				]
			},
			'Z': {
				0: [
					[0,0],
					[1,0],
					[1,1],
					[2,1]
				],
				90: [
					[1,0],
					[0,1],
					[1,1],
					[0,2]
				],		
				180: [
					[0,0],
					[1,0],
					[1,1],
					[2,1]
				],
				270: [
					[1,0],
					[0,1],
					[1,1],
					[0,2]
				]
			}
		}


		this.drawBlock = function(mode) {
			if (mode == "move") {
				character = this.type;
			}
			else if (mode == "final") {
				character = this.type.toLowerCase();
			}
			else {
				character = blank;
			}

			for (var i = 0; i < 4; i++)
			{
				var X = this.blockSpots[this.type][this.rotation][i][0] + this.left;
				var Y = this.blockSpots[this.type][this.rotation][i][1] + this.top;
				pit.updateSpace(X,Y,character);
			}
			pit.printPit();
		}

		this.moveRight = function() {
			if (!paused) {
				var rightLimit = this.findRightLimit();
				if (this.left < rightLimit) {
					this.drawBlock("erase");
					this.left++;
					this.drawBlock("move");
				}
			}
		}

		this.moveLeft = function() {
			if (!paused) {
				var leftLimit = this.findLeftLimit();
				if (this.left > leftLimit) {
					this.drawBlock("erase");
					this.left--;
					this.drawBlock("move");
				}
			}
		}

		this.dropToBottom = function() {
			if (!paused) {
				var bottomLimit = this.findBottomLimit();
				if (this.top < bottomLimit) {
					this.drawBlock("erase");				
					this.top = bottomLimit;
					this.drawBlock("final")				
				}
			}	
		}

		// Find lowest point block can drop to
		this.findBottomLimit = function() {
			var bottomLimit = pit.h-1;
			var spots = this.blockSpots[this.type][this.rotation];
			for (var i = 0; i < 4; i++) {
				var columnToCheck = spots[i][0] + this.left;
				var rowToStartFrom = spots[i][1] + this.top;
				var bottomForColumn = pit.getLastFreeRowForColumn(columnToCheck,rowToStartFrom)
				bottomForColumn -= spots[i][1];
				if (bottomForColumn < bottomLimit) {
					bottomLimit = bottomForColumn;
				}
			}
			return bottomLimit;
		}

		// Find right-most point block can move to
		this.findRightLimit = function() {
			var rightLimit = pit.w-1;
			var spots = this.blockSpots[this.type][this.rotation];
			for (var i = 0; i < 4; i++) {
				var columnToStartFrom = spots[i][0] + this.left;
				var rowToCheck = spots [i][1] + this.top;
				var rightLimitForRow = pit.getLastFreeColumnToRightForRow(columnToStartFrom,rowToCheck);
				rightLimitForRow -= spots[i][0];
				if (rightLimitForRow < rightLimit) {
					rightLimit = rightLimitForRow;
				}
			}
			return rightLimit;
		}

		// Find left-most point block can move to
		this.findLeftLimit = function() {
			var leftLimit = 0;
			var spots = this.blockSpots[this.type][this.rotation];
			for (var i = 0; i < 4; i++) {
				var columnToStartFrom = spots[i][0] + this.left;
				var rowToCheck = spots[i][1] + this.top;
				var leftLimitForRow = pit.getLastFreeColumnToLeftForRow(columnToStartFrom,rowToCheck);
				leftLimitForRow -= spots[i][0];
				if (leftLimitForRow > leftLimit) {
					leftLimit = leftLimitForRow;
				}
			}
			return leftLimit;
		}

		//
		// Rotation!
		//

		this.rotate = function(clockwise) {

			// Get new rotation, clockwise +90 or counterclockwise -90
			newRotation = this.rotation + (clockwise ? 90 : -90);
			if (newRotation > 270 || newRotation < 0) {
				newRotation = 0;
			}
			
			// Check to see if block will stay in bounds with new rotation
			var outOfBounds = false;
			for (i = 0; i < 4; i++) {
				newColumn = this.blockSpots[this.type][newRotation][i][0] + this.left;
				if (newColumn >= pit.w) {
					outOfBounds = true;
				}
			}

			// If block will stay in bounds, erase, set new rotation, and redraw
			if (!outOfBounds) {
				this.drawBlock("erase");
				this.rotation = newRotation;
				this.drawBlock("move");
			}
		}

	}

	// Drop block one space, reset timer to drop again unless at last free row
	function drop() {
		if (!paused) {
			var bottomLimit = newBlock.findBottomLimit();
			if (newBlock.top < bottomLimit) {
				newBlock.drawBlock("erase");
				newBlock.top++;
				document.getElementById('blockreport').innerHTML = 'Block is at row ' + newBlock.top;
				newBlock.drawBlock("move");
				window.setTimeout(drop,1000);
			}
			else {
				newBlock.drawBlock("final")
				document.getElementById('blockreport').innerHTML = 'Block is at row ' + newBlock.top + ' and is done dropping';
				pit.checkRows();
			}
		}
	}


	// Pause and resume game
	function pause() {
		if (!paused) {
			paused = true;
			document.getElementById('pause').innerHTML = "Resume";
		}
		else {
			paused = false;
			document.getElementById('pause').innerHTML = "Pause";
			window.setTimeout(this.drop,1000);
			window.setTimeout(timer,1000);
		}
	}

	// Score turn and update scoreboard based on lines completed
	// then start new turn with a new block
	function scoreTurn(turnlines) {
		lines += turnlines;
		switch (turnlines) {
			case 0:
				tetris = 0;
				break;
			case 1:
				tetris = 0;
				score += 100;
				break;
			case 2:
				tetris = 0;
				score += 300;
				break;
			case 3:
				tetris = 0;
				score += 600;
				break;
			case 4:
				tetris ++;
				score += 800;
				break;
		}
		if (tetris == 2) {
			score += 1600;
			tetris = 0;
		}
		updateScores();
		newBlock = new block(); 
		window.setTimeout(drop,1000);
	}

	//
	//	Game timer
	//
	function timer() {
		if (!paused) {
			gametime++;
			document.getElementById("time").innerHTML = gametime;
			window.setTimeout(timer,1000);
		}
	}

	//
	// Touch event and screen orientation listeners
	//

	window.addEventListener('touchstart', touchStart, false);
	window.addEventListener('touchend', touchEnd, false);

	//
	// Initialize new game
	//

	// Create pit object
	var pit = new pitTemplate(initialOrientation,blank);

	// Print blank bit
	pit.printPit();

	// Set scoreboard
	updateScores();
	
	// Start game with new block
	var newBlock = new block(); 
	newBlock.drawBlock();
	window.setTimeout(drop,1000);
	window.setTimeout(timer,1000);




</script>

</body>
</html>  
